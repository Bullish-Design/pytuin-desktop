# Pytuin-Desktop Developer Guide

## Introduction

This guide provides a detailed overview of the internal architecture, design philosophy, and development conventions of the Pytuin-Desktop library. It is intended for contributors and maintainers who plan to extend or modify the library.

---

## Architectural Overview

```
pytuin_desktop/
├── models.py          # Core data models (Pydantic)
├── parser.py          # .atrb → model parsing
├── builders.py        # Block builder abstractions
├── editor.py          # DocumentEditor for building and saving documents
├── discovery.py       # Template discovery utilities
├── content/           # Template definitions (.templateer)
├── tests/             # Unit and integration tests
```

### Design Principles

1. Template-Driven Generation – All `.atrb` outputs are defined through declarative Jinja-like templates.
2. Fluent Composition – Builders expose intuitive methods for chaining block creation.
3. Strict Validation – Pydantic models enforce type safety and schema integrity.
4. Round-Trip Consistency – Any document generated by `DocumentEditor` must be parsable by `AtrbParser` without data loss.

---

## Core Components

### 1. Template Layer

Located in `.templateer/`, this layer mirrors the `.atrb` file format using subclasses of `TemplateModel`. Each class contains a template string and fields that populate it.

Example:

```python
class ParagraphBlockTemplate(TemplateModel):
    __template__ = PARAGRAPH_BLOCK_TEMPLATE
    block_id: str
    text_color: str = "default"
    content: list[TextContentTemplate] = []
```

### 2. Model Layer

Defined in `models.py`. Provides structured representations of blocks and documents via Pydantic. Models enforce schema compliance and assist the parser in data validation.

### 3. Builder Layer

Implemented in `builders.py`. Provides a fluent interface for constructing blocks without referencing templates directly.

Example:

```python
BlockBuilder.paragraph("Sample text")
BlockBuilder.heading("Title", level=2)
```

### 4. Editor Layer

Defined in `editor.py`. Manages complete document composition, including metadata and block ordering. Responsible for rendering `.atrb` files through the `DocumentTemplate`.

Key methods:
- `create(name)` – Initializes a new document.
- `add_block(template)` – Appends a block to the document.
- `save(path)` – Writes the document to disk.

### 5. Parser

Located in `parser.py`. Responsible for reading `.atrb` files and converting them into model instances. Ensures that each block is properly mapped to its type.

### 6. Template Discovery

Implemented in `discovery.py`. Dynamically locates all available `TemplateModel` subclasses within `.templateer` and exposes them through the `load_atrb_templates()` API.

---

## Testing Strategy

Tests are structured by development step and feature focus.

| Step | Focus Area | Example Test Files |
|------|-------------|--------------------|
| 1–3  | Text and inline templates | `test_text_styles.py` |
| 4–7  | Block structures | `test_paragraph_block.py`, `test_block_types_v1.py` |
| 8–10 | Document rendering | `test_single_paragraph_v1.py`, `test_empty_document_v1.py` |
| 11–12 | Complex/script blocks | `test_complex_v1.py` |
| 13   | Integration workflow | `test_integration_v1.py` |

Each test ensures template rendering correctness and parser compatibility.

---

## Extending the Library

### Adding a New Block Type

1. Define a template under `.templateer/`:

```python
MY_BLOCK_TEMPLATE = """id: "{{ block_id }}"
type: my_block
props:
  customProperty: {{ custom_property }}
content: []"""

class MyBlockTemplate(TemplateModel):
    __template__ = MY_BLOCK_TEMPLATE
    block_id: str
    custom_property: str = "default"
```

2. Add a builder method:

```python
@staticmethod
def my_block(custom_property="default"):
    return MyBlockTemplate(block_id=str(uuid4()), custom_property=custom_property)
```

3. Add test coverage under `tests/test_my_block_v1.py`.

4. Run tests with `pytest -vv`.

---

## Development Conventions

- Use relative imports (`from . import ...`).
- Follow PEP 8 style conventions.
- All models must inherit from `pydantic.BaseModel` or `sqlmodel.SQLModel` (for database integration).
- Template models must subclass `TemplateModel`.
- New functionality must include full test coverage.

---

## Debugging and Diagnostics

- Use `pytest -s` for detailed output.
- Enable template debugging via environment variable:
  ```bash
  export TEMPLATEER_DEBUG=1
  ```
- Logs during template discovery help identify import issues.

---

## Future Roadmap

- Nested and composite block rendering
- Table and list block support
- Persistent storage via SQLModel
- Runtime template reloading

---

## Summary

Pytuin-Desktop follows a modular architecture centered around template-driven generation, strict data validation, and reliable round-trip transformations. Understanding the relationships between templates, builders, editors, and models allows contributors to extend the system effectively while preserving its consistency.
